$card-border: 1px solid black;
$card-border-radius: 5px;
$hover-scale: 1.5;
$hover-offset-y: -20px;

$card-count: 15;
$card-positions: ();
@for $i from 1 through $card-count {
  $card-positions: append($card-positions, (0px, 0px, -10deg));
}

.centerDeck {
  top: 35%;
  left: 50%;
  display: flex;
  gap: 15px;
}

.wrap {
  margin: $spacing-m 0;
  display: flex;
  margin: auto 0;
  position: absolute;
  justify-content: center;

  .card {
    width: var(--card-width);
    left: calc(var(--i, 0) * (var(--card-width) * -1 + var(--card-spacing)));

    position: relative;
    transition: transform 0.2s ease-in-out;

    // A lógica de ROTAÇÃO que é estática PODE continuar no loop
    @for $i from 1 through $card-count {
      &:nth-child(#{$i}) {
        $rotate: 0;
        @at-root .left & {
          $rotate: nth(nth($card-positions, $i), 3) + 16;
        }
        @at-root .right & {
          $rotate: nth(nth($card-positions, $i), 3);
        }
        transform: translateY(0px) rotate(#{$rotate}deg);
      }
    }

    // O hover continua funcionando
    &.canHover:hover {
      z-index: 2;
      transform: translateY($hover-offset-y) scale(1.1);
    }
  }
}
